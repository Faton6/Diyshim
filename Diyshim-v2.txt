Diyshim - рабочие название, совпадения и НАМЁКИ случайны.

Справка ещё конечно не готова, но уже включает всё, чтобы написать, собрать и запустить программу.

Справку создал Faton, студент фак. комьютерной безопасности 2020 - 2026.

Смысл справки - сбор необходимых команд и действий для выполнения задач по программированию.

Если ты в виме:
Для перехода в параграф будь в командном режиме (по умолчанию в нём у тебя открывается файл, т.е. ничего не трогай)
и напиши /номер_оглавление нажми Энтер и нажми   n   для перехода на следуещие упоминание! 
(пример действий: /2.3 <Enter> <n> )

0 Предметный указатель (оглавление короче)
0.1 Введение
1.0 Linux
1.1 Выбор системы для программирования
1.2 Базовый набор команд в linux
1.2.1 Файловые команды
1.2.2 Управление процессами
1.2.3 Прочие полезные команды
1.3 Vim / vi
1.4 Что-то тут будет
2.0 Компиляция
2.1 СБОРКА на g++!!!
2.2 Оптимизация кода  
2.3 Стадии компиляции
2.4 Стандарты С++ (команды для выбора стандарта)
2.5 Предупреждения (команды для вызовов предупреждений)
3.1 Cmake - система сборки
4.1 Git / Github 
4.2 Помощь в улучшении справки


0.1
Введение... потом
1.0 Linux //расширить
Постоянная работа на linux реальный буст к навыкам программиста, тем более,
что он будет необходим в промышленном програмирование.
К тому же здесь можно работать эффективнее и быстрее, чем в окнах.
Как минимум компиляция нетривиальных прог быстрее. Ну и вообще, ты же на КБ.

Linux - Unix-подобная система, если просто, то это ядро системы, поверх ядра уже накатан графический интерфейс (GUI), который можно менять  прямо в консоли, даже не закрывая программ.

1.1 Здесь краткий рассказ о выборе дистрибутива Linux

1.2 Базовый набор команд в linux:

1.2.1 Файловые команды|

ls – список файлов и каталогов
ls -al – форматированный список со скрытыми каталогами и файлами
cd dir – сменить директорию на dir
cd – сменить на домашний каталог
pwd – показать текущий каталог
mkdir dir – создать каталог dir
rm file – удалить file
rm -r dir – удалить каталог dir
cp file1 file2 – скопировать file1 в file2
cp -r dir1 dir2 – скопировать dir1 в dir2; создаст каталог dir2, если он не существует
mv file1 file2 – переименовать или переместить file1 в file2. если file2 существующий каталог - переместить file1 в каталог file2
touch file – создать file
cat > file – направить стандартный ввод в file
more / less file – вывести содержимое file
head file – вывести первые 10 строк file
tail file – вывести последние 10 строк file

1.2.2 Управление процессами

ps – вывести ваши текущие активные процессы
top – показать все запущенные процессы
kill 10 – убить процесс с номером id 10, посмотреть с помощью ps или top
killall proc – убить все процессы с именем proc
bg – список остановленных и фоновых задач; продолжить выполнение остановленной задачи в фоне
fg – выносит на передний план последние задачи
fg n – вынести задачу n на передний план
Права доступа на файлы
chmod octal file – сменить права file на octal, раздельно для пользователя, группы и для всех добавлением:
4 – чтение (r)
2 – запись (w)
1 – исполнение (x)

Примеры:
chmod 777 – чтение, запись, исполнение для всех
chmod 755 – rwx для владельца, rx для группы и остальных.
Дополнительные опции: man chmod.

Поиск|

grep <что-то> files – искать что-то в files
command | grep pattern – искать pattern в выводе command
locate file – найти все файлы с именем file
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Системная информация|

date – вывести текущую дату и время
cal – вывести календарь на текущий месяц
uptime – показать текущий аптайм
w – показать пользователей онлайн
whoami – имя, под которым вы залогинены
finger user – показать информацию о user
uname -a – показать информацию о ядре
cat /proc/cpuinfo – информация ЦПУ
cat /proc/meminfo – информация о памяти
man command – показать мануал для command
df – показать инф. о использовании дисков
du – вывести “вес” текущего каталога
free – использование памяти и swap
whereis app – возможное расположение программы app
which app – какая app будет запущена по умолчанию
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Архивация|

tar cf file.tar files – создать tar-архив с именем file.tar содержащий files
tar xf file.tar – распаковать file.tar
tar czf file.tar.gz files – создать архив tar с сжатием Gzip
tar xzf file.tar.gz – распаковать tar с Gzip
tar cjf file.tar.bz2 – создать архив tar с сжатием Bzip2
tar xjf file.tar.bz2 – распаковать tar с Bzip2

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Клавиатурные сочетания|

Ctrl+C – завершить текущую команду
Ctrl+Z – остановить текущую команду, продолжть с fg на переднем плане или bg в фоне
Ctrl+U – удалить строку


1.3 Vim / vi
Vim - редактор текста, который любят все, кто хотя бы немного умеет им пользоваться. (Одобрено Булгачём!)
Этот текст полностью набран в vim, поэтому начну наконец писать что-то полезное:
Прежде всего, в виме есть два режима: режим команд и режим записи.
Файл отрывается в редиме команд, т.е. просто написать текст не получится, нужно будет переключить режим, вот способ преключения:

нажатие клавиши <i> переведёт в режим записи 
нажатие <esc> переведёт обратно в режим команд

То есть алгоритм действий:

1. В командной строке набрать vi <имя файла> 
2. Нажать <i>
3. Написать что-то
4. Вернуться в режим команд <esc>
5. Написать команду для закрытия ( <:wq> - пример команды, вводить двоеточие НАДО т.е. на клаве мы набрали shift+; а после без пробелов wq и <enter>) 


Команды Vim:


== В командном режиме: ==
h-влево		j- вниз	   k - вверх	l - вправо      перемещение в разные стороны
i                         режим вставки
I                         добавление в начало строки
a                         режим добавления
A                         добавление в конец строки
o                         добавить строку сразу за текущей
O                         добавить строку перед текущей
R                         писать поверх имеющегося текста
u                         отмена предыдущего действия (undo)
CTR-R                     отмена отмены предыдущего действия (redo)
dd                        вырезать (удалить) строку
yy                        копировать строку

Работа в буфером обмена!!!
Если ты в режиме "ВСТАВКА":

копировать: 	Ctrl+Shift+c 
вставить:   	Ctrl+Shift+v

Если ты в режиме команд:
В виме есть свой собственный буфер обмена, 
т.е. где-то что-то скопировать и сразу вставить нельзя, нужно написать	

<"*p>

без указания ковычек и * вставится, то что ты скопировал в виме.

p                         вставить из буфера обмена 
<n>d                      удалить n+1 строку
<n>y                      скопировать n+1 строку
ESC                       перейти в режим просмотра
DEL                       удалить следующий символ
:<n>                      перейти на строку #n
%                         перейти к парной скобке
:e **/filename.c          редактировать файл (с поиском по имени)
:w [fname]                записать изменения
:wa                       сохранить изменения во всех файлах
:q                        выйти из редактора
:q!                       выйти из редактора, не сохраняя изменения

:pwd                      текущий каталог
:cd [path]                перейти в другой каталог
:!команда                 выполнить команду - man, git, и так далее
                            стрелочками веерх и вниз можно автодополнять
                            команды и искать по истории
== Подсветка синтаксиса ==
:syntax on                включить подсветку
:syntax off               выключить подсветку (по умолчанию)

== Перенос строк ==
:set wrap                 разрешить word wrap (по умолчанию)
:set nowrap               запретить word wrap

== Выделение ==
v + hjkl(или стрелочки)   выделение текста
SHIFT + v                 выделить строку
p                         вставить
y                         копировать
d                         удалить

== Отступы ==
[#]>                      сдвинуть выделенное вправо
[#]<                      сдвинуть выделенное влево
[#]>>                     сдвинуть строку вправо
[#]<<                     сдвинуть строку влево

== Поиск в файле ==
/Выражение               поиск выражения в файле
\cВыражение              поиск без учета регистра
n                        следующее совпадение
N                        предыдущее совпадение


== Поиск по всему проекту ==
:vimgrep /EXPR/ **/*.c   поиск по регулярному выражению
:copen                   показать все найденные места
:close                   скрыть все найденные места
:cn                      переход к следующему результату
:cp                      переход к предыдущему результату

== Нумерация строк ==
:set nu              включить нумерацию строк
:set nonumber            отключить нумерацию строк


Не переживай, скоро ты всё выучешь(нет)

2.0 Компиляция!

(используй gcc для компиляции программ на Си     и    g++ на Си++)

Компилятор g++ делает несколько шагов, а не только один. Вот небольшое объяснение их смысла:

    Препроцессирование: Создание кода, более не содержащего директив. Вещи вроде «#if» не могут быть поняты компилятором, поэтому должны быть переведены в реальный код. Также на этой стадии разворачиваются макросы, делая итоговый код больше, чем оригинальный. [1]

    Компиляция: Берется обработанный код, проводятся лексический и синтаксический анализы, и генерируется ассемблерный код. В течение этой фазы, gcc выдает сообщения об ошибках или предупреждениях в случае, если анализатор при парсинге вашего кода находит там какие-либо ошибки. Если запрашивается оптимизация, gcc продолжит анализировать ваш код в поисках улучшений и манипулировать с ними дальнейшем. Эта работа происходит в многопроходном стиле, что показывает то, что иногда требуется больше одного прохода по коду для оптимизации. [2]

    Ассемблирование: Принимаются ассемблерные мнемоники и производятся объектные коды, содержащие коды команд. Часто недопонимают то, что на стадии компиляции не производятся коды команд, это делается на стадии ассемблирования. В результате получаются один или более объектных файла, содержащие коды команд, которые являются действительно машинозависимыми. [3]

    Компоновка: Трансформирует объектные файлы в итоговые исполняемые. Одних только кодов операции недостаточно для того, чтобы операционная система распознала и выполнила их. Они должны быть встроены в более полную форму. Эта форма, известная как бинарный формат, указывает, как ОС загружает бинарный файл, компонует перемещение и делает другую необходимую работу. ELF является форматом по умолчанию для Linux на x86. [4]

2.1 Сборка

Для сборки программы необходимо указать компилятору g++ файлы исходного кода, например команда g++ main.cpp скомпилирует исходный код файла main.cpp в исполняемый фаил a.out (если компилятору не указать имя выходного файла то по умолчанию именем будет a.out)

    -o <name> - Имя выходного файла

    Пример: Команда g++ -o myexe main.cpp скомпилирует фаил main.cpp в исполняемый фаил myexe.

    Можно передавать несколько исходных файлов для сборки, например g++ -o myexe file1.cpp file2.cpp.

    -c - Создание объектного файла

    Пример: Для создания объектного файла необходимо указать компилятору ключи -c и -o: g++ -c -o main.o main.ppp, данной командой компилятор g++ создает объектный фаил main.o из файла main.cpp

    Для сборки программы из объектных файлов необходимо указать компилятору в качестве входных параметров не файлы исходного кода а объектные файлы: g++ -o myexe foo.o main.o bar.o - создает программу из объектных файлов foo.o main.o bar.o

    -I<include_path> - Указание каталога для поиска подключаемых файлов

    Пример: g++ -o myexe -I/my/path/to/include main.cpp

    -L<library_path> - Указание каталога для поиска библиотек
    -l<library> - Указание конкретной библиотеки для линковки

2.2 Оптимизация кода

g++ предоставляет очень простой способ производить оптимизацию: флаг -O. --- ускоряет выполнение вашего кода, и сжимает размер итогового кода. 
У неё существует пять вариантов, но забей и используй в КАЖДОЙ программе -О3, только так у тебя будут работать встаиваемые функции (inline) 
степени оптимизации: от -O0 (O ноль) до -O3. "0" означает отсутствие оптимизации, а "3" — наивысший уровень оптимизации. "1" и "2" находятся между этими краям.
Если просто используете -O, это будет означать -O1.

2.3 Стадии компиляции.
(будет на экзе по словам Лебедева!!!)
Есть такие флаги:

    -c останавливает на стадии ассемблирования, но пропускает компоновку. Результатом является объектный код.

    -E останавливает на стадии препроцессинга. Все директивы препроцессора развернуты, так что вы видите только чистый код.

    -S останавливает после компиляции. Она оставляет вас с ассемблерным кодом.


2.4 Стандарты С++

    -std=c++98 - C++98
    -std=c++11 - C++11
    -std=c++14 - C++14
    -std=c++17 - C++17
    -std=c++2a - C++20

2.5 Предупреждения

    -Wall - Выводит большинство предупреждений
    -Wfloat-equal - Предупреждает о не безопасном сравнении
    -Wsign-conversion или -Wsign-promo - Предупреждения преобразования signed в unsigned (и обратно)
    -Wold-style-cast - Выводит C Style преобразования типов
    -Warray-bounds - Доступ за пределы массива
    -Wdiv-by-zero - Предупреждать о делении на 0
    -Wdouble-promotion - Предупреждает о преобразовании с float на double
    -Wbool-compire - Предупреждение о сравнении int с bool

3.1 Cmake

Cmake нужен для сборки проекта из нескольких исходников

Терминология

Файл CMakeLists.txt служит скриптом (рецептом, сценарием) сборки проекта. Обычно один такой файл собирает все исходники в своём каталоге и в подкаталогах, при этом подкаталоги могут содержать, а могут не содержать дочерние файлы CMakeLists.txt.

    В cmake есть “цель” (“target”) - компонент, который следует собрать. Компонент может быть исполняемым файлом, так и статической либо динамической библиотекой.
    В cmake есть “проект” (“project”) - это набор компонентов, по смыслу похожий на Solution в Visual Studio.
    В cmake есть “флаги” (flags) - это аргументы командной строки для компилятора, компоновщика и других утилит, вызываемых при сборке.
    В cmake есть переменные, и в процессе интерпретации файла CMakeLists.txt система сборки cmake вычисляет ряд встроенных переменных для каждой цели, тем самым получая флаги. Затем cmake создаёт вторичный скрипт сборки, который будет напрямую вызывать компилятор, компоновщик и другие утилиты с вычисленными флагами.

Сборка проекта из командной строки (Linux)
Использование CMake в простейшем случае выглядит следующим образом. В корне репозитория создается файл CMakeLists.txt примерно такого содержания:

начало:
(в этом файлике)

cmake_minimum_required(VERSION 3.1)

# так пишутся комментарии

project(project_name)

find_library(PTHREAD_LIBRARY pthread)
find_library(PCRE_LIBRARY pcre)

include_directories(include)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED on)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")

add_executable(main src/Main.cpp src/HttpServer.cpp)

target_link_libraries(main ${PTHREAD_LIBRARY} ${PCRE_LIBRARY})

конец.

Хочется надеяться, какая строчка здесь что означает, разберётесь включив логику и английский. Затем исходники складываются в каталог src, а заголовочные файлы — в каталог include. Для сборки проекта говорим:
(уже в консоле)
mkdir build
cd build
cmake --build
//make нужно писать если что-то не так

Просто, не правда ли? // нет, надо разобраться и переписать

4.1 Git / Github

(Для работы с Github нужен Git) // удалить или оставить?

Система контроля версий Git

Так называют программу, которая позволяет хранить разные версии одного и того же документа, легко переключаться между ранними и поздними вариантами, вносить и отслеживать изменения.

Скорее всего у тебя Git уже стоит в Linux, в остальных системах не знаю.
Но если что, вот команда: sudo apt install git (для Ubuntu)

Теперь время создать профиль на Github.com , но это уже совсем просто.

*****************************************//разбить на подкаталоги

Git установлен, профиль на GitHub создан. Осталось добавить SSH-ключ и можно приступать к работе с проектом.

Что такое SSH-ключ и зачем он нужен?

Чтобы работать со своего компьютера с GitHub, иметь доступ к проектам, хранящимся на сервисе, выполнять команды в консоли без постоянного подтверждения пароля, нужно пройти авторизацию у сервера. В этом помогают SSH-ключи.

Каждый SSH-ключ содержит пару: открытый (публичный) и закрытый (приватный) ключ. Открытый ключ отправляется на сервер, его можно не прятать от всех и не переживать, что кто-то его увидит и украдёт. Он бесполезен без своей пары — закрытого ключа. А вот закрытый ключ — секретная часть. Доступ к нему должен быть только у вас.
(привет теория чисел, а именно, простые числа, которые невозможно разложить на множители
за короткий интервал времени, скажем, меньше чем за пару лет)

Вы отправляете какую-то информацию на сервер, где хранится ваш публичный ключ,
сервер понимает, что вы это вы, то есть идентифицирует именно вас, и даёт вам какой-то ответ.
И только вы можете расшифровать этот ответ, только у вас есть подходящий закрытый ключ.
Ваш пароль кто-то может узнать или подобрать, а чтобы получить ваш приватный SSH-ключ, злоумышленнику придётся взломать ваш компьютер.

Чтобы пройти авторизацию по SSH-ключу, его надо сгенерировать или найти уже ранее созданный ключ на своём компьютере.

Сначала проверим, есть ли уже на компьютере ключ. По умолчанию SSH-ключи хранятся в каталоге ~/.ssh, поэтому нужно проверить содержимое этого каталога.

    Открываем консоль.
    Вводим cd ~/.ssh, чтобы перейти в нужный каталог.
    Переходим в нужную директорию.
    Используем ls, чтобы увидеть список всех файлов в каталоге.
    Открываем список файлов в директории.
    Ищем пару файлов с названиями вида имя и имя.pub.
    Обычно имя — id_rsa, id_dsa, id_ecdsa или id_ed25519.
    Файл с расширением .pub — ваш публичный ключ, а второй — ваш приватный, секретный ключ.
    Если таких файлов или даже каталога .ssh у вас нет, вы можете их сгенерировать.
!!! Для этого делаем следующее.
        Открываем консоль и вводим команду:

        ssh-keygen -t rsa -b 4096 -C "your_mail@example.com"

        Указываем тот адрес электронной почты, который вводили при регистрации на GitHub.
        Генерируем ключ.
        Далее нужно указать расположение файла для сохранения ключа. Если вы не введёте путь до файла и просто нажмёте Enter, ключ сохранится в файле, указанном в скобках.
        Теперь нужно установить пароль к вашему ключу и дважды ввести его. Если вы не хотите вводить пароль каждый раз, когда используете ключ, пропустите этот шаг, нажав «Enter», и ничего не вводите.
        Указываем расположение ключа и вводим пароль.
    Добавляем ключ в ssh-agent (сгенерированный или уже существующий). Проверяем доступность ключа командой eval "$(ssh-agent -s)" и добавляем с помощью ssh-add ~/.ssh/your_key_name, где указываем верный путь до файла с ключом и его имя.
    Несколько важных примечаний:
        Если вы захотите переименовать ключ, могут возникнуть проблемы. Их можно решить, добавив в ~/.ssh/config связь ключа с доменом.
        Если у вас Linux, может понадобится переназначить для ~/.ssh права доступа командой chmod 700 ~/.ssh/

    После того как создан ключ, его нужно добавить на GitHub. Для этого копируем его содержимое с помощью одной из следующих команд:
        Введите команду cat ~/.ssh/id_rsa.pub, контент документа появится прямо в консоли и вы сможете скопировать ключ оттуда.
	Напоню, что при копировании/вставки текста в консоль, надо нажимать по мимо Ctrl ещё и Shift, т.е в данном случае нужно нажать Ctrl+Shift+c 

        Можно пойти другим путём, открыть файл id_rsa.pub прямо в папке и просто скопировать содержимое оттуда.
    Переходим на страницу для работы с ключами в вашем профиле на GitHub.
https://github.com/settings/keys
    Нажимаем кнопку New SSH key (новый SSH-ключ). Вводим имя ключа (можно придумать абсолютно любое) в поле Title (название), а в Key (ключ) вставляем сам ключ из буфера обмена. Теперь нажимаем Add SSH key (добавить SSH-ключ).

Теперь, наконец-то, мы можем начать работу с самим проектом.
Работа с репозиториями

Для начала определим, что такое репозиторий. Это рабочая директория с вашим проектом.
По сути, это та же папка с C++ и прочими файлами, что хранится у вас на компьютере,но находится на сервере GitHub.
Поэтому вы можете работать с проектом удалённо на любой машине, не переживая, что какие-то из ваших файлов потеряются — все данные будут в репозитории при условии, что вы их туда отправите.

Если над проектом трудится команда разработчиков, как правило, создаётся общий репозиторий, в котором находится рабочая версия проекта (назовём его мастер-репозиторий).
При этом каждый пользователь клонирует себе в профиль оригинальный репозиторий и работает именно с копией.
Такая копия называется форком. Так как форк — ваша персональная версия мастер-репозитория, в нём вы можете пробовать разные решения, менять код и не бояться что-то сломать в основной версии проекта.

Как сделать форк мастер-репозитория?

Заходим в нужный репозиторий, нажимаем на «вилку» с надписью fork. Форк репозитория создан и находится в вашем профиле на GitHub.

Теперь нужно склонировать форк себе на компьютер, чтобы вести работу с кодом локально. Тут нам и пригодится SSH.

Открываем консоль, переходим в директорию, где хотим сохранить папку с проектом, и вводим команду:

git clone git@github.com:your-nickname/your-project.git

Если вы правильно настроили SSH-ключи, Git начнёт процесс копирования репозитория на ваш компьютер. 
Если вы видите ошибку, в которой написано Error: Permission denied (publickey), скорее всего, вы ошиблись где-то при выполнении инструкции по настройке SSH-ключа.

Если вы не хотите вручную вводить адрес репозитория, вы можете зайти на страницу проекта, нажать зелёную кнопку Clone or download (клонировать или скачать), выбрать Clone with SSH (клонировать по SSH) и скопировать адрес, который находится в текстовом поле. Этот адрес вы можете вставить в команду git clone.

Кстати, если вы хотите, чтобы название папки с проектом у вас на компьютере отличалось от имени репозитория, можете дополнить команду клонирования, добавив в конце другое название:

git clone git@github.com:_your-nickname_/_your-project_.git folder_name

Теперь, на вашем компьютере, в папке your_project или в той, название которой вы указали самостоятельно, находится полная копия репозитория c GitHub.

Чтобы начать работу с проектом, надо оказаться в его директории. 

Работу над проектом принято вести в ветках. В каждом репозитории есть как минимум одна ветка.
Это основная ветка, которую создаёт сам Git, она называется master .
Обычно в ней находится стабильная версия программы без ошибок.
Если вы хотите исправить баг, добавить новую функциональность в проект, попробовать какую-то технологию, но не хотите сломать код в основной ветке, вы ответвляетесь из master и трудитесь в своей новой ветке.
Здесь вы можете реализовывать свои идеи, не переживая, что рабочий код сломается.

Создадим новую ветку. Открываем терминал, вводим команду git branch. Она показывает список веток, с которыми мы работаем в проекте, и выделяет текущую. Если мы находимся в master создаём новую ветку: git checkout -b имя-новой-ветки.

Если текущая ветка не master, сначала переключимся в основную ветку: git checkout master. Мы делаем это, чтобы новая ветка содержала свежую, на момент создания, рабочую версию проекта.
Эта команда позволяет переключаться между существующими ветками в проекте, после git checkout надо указать название нужной ветки.

Если вы ошиблись в названии, например, допустили опечатку, вы можете изменить название ветки с помощью команды: git branch -m старое-имя-ветки новое-имя-ветки.

После того как вы создали ветку, поработали в ней у себя локально — нужно сохранить результат, чтобы он не пропал и в итоге оказался в репозитории.

Если вы хотите сохранить изменения не во всех файлах, для начала можно ввести команду git status. Она покажет текущее состояние в вашей ветке, а именно список с названиями изменённых файлов, если они есть, и укажет на те, которые ожидают записи и сохранения (обычно они выделены красным цветом).

Перед тем, как зафиксировать изменения отдельных файлов, нужно добавить файлы в набор этих изменений. Воспользуйтесь командой git add имя-файла. Если название очень длинное, вы можете начать его писать, затем нажать Tab и консоль сама предложит вам продолжение пути к файлу.

Если вы хотите сохранить все изменения разом, вводите git add -A.

Теперь мы можем сделать коммит, то есть зафиксировать все сохранённые изменения и дать им название. Это делается с помощью команды git commit -m "ваше сообщение". Текст сообщения должен быть лаконичным и в то же время сообщать о том, что делает коммит (внесённые изменения). Например, «добавляет имя наставника в Readme», «вводит функцию сортировки изображений», «правит ошибку в поиске городов на карте».

Сохранения зафиксированы, всё? Они теперь в репозитории и видны коллегам? Пока нет. Те изменения, которые мы внесли и сохранили, пока локальны. Их нужно послать на GitHub.

Чтобы отправить свои изменения (коммиты) в репозиторий на GitHub, введите команду git push origin название-текущей-ветки, где origin означает репозиторий, который был склонирован на компьютер, то есть ваш форк.

Теперь заходим на страницу нашего форка и создаём пулреквест, чтобы слить свой код с данными в мастер-репозитории. Что такое пулреквест? Это предложение изменить код в репозитории.

Любое предложение можно принять или отвергнуть. Так же и с пулреквестом.
После его создания, он должен получить ревью и одобрение так называемого коллаборатора — пользователя GitHub, который имеет права администратора в мастер-репозитории.
Им может быть ваш коллега-разработчик, техлид, наставник.
Если к вашему коду нет вопросов, пулреквест принимается и изменения из вашей ветки попадают в master главного репозитория.
Если в код нужно внести изменения, пулреквест отклоняется, и вам нужно снова пройти по цепочке локальные изменения — сохранение — коммит — пуш, только пулреквест заново делать не нужно.
Если вы продолжаете вести работу в той же ветке и пулреквест ещё не принят, все ваши изменения автоматически добавятся в пулреквест, созданный из этой ветки после команды git push origin название-текущей-ветки.

Вы исправили код, наставник или техлид одобрил ваши правки и принял пулреквест.
Теперь код в мастер-репозитории обновился, а в вашем форке нет, вы ведь не обновляли свою версию репозитория с тех пор, как клонировали её себе на компьютер. 
Приведём форк в актуальное состояние.

    В локальном репозитории вводим команду git checkout master, переходим в master.
    Теперь забираем (подтягиваем) изменения из ветки master мастер-репозитория git pull academy master. Academy здесь — сокращённое название мастер-репозитория, такое имя используется в проектах студентов Академии, вы можете выбрать любое другое название.
    Если консоль выдаёт ошибку и говорит, что не знает директории с таким именем, нужно добавить ссылку на этот репозиторий:

    git remote add academy git@github.com:your-repo.git

    Вместо academy указывайте своё название и оно закрепится за этим репозиторием.
    Теперь отправьте изменения уже из своей ветки master в ваш форк на GitHub с помощью команды git push origin master.

Готово, теперь форк и оригинальный репозиторий находятся в актуальном состоянии.
4.2 Помощь в улучшении справки
В целях развития навыков работы с Git и Github, а так же в улучшении и дополнении этой справки,
предлагаю читателю внести свой вклад и сделать вышеописанные действия по отошению к этой справке.
Т.е добавь что-то полезное или исправь ошибки, коих наверняка дохрена.

Ссылка на репозиторий:

https://github.com/Faton6/Diyshim

Прямая ссылка на клонирование:

https://github.com/Faton6/Diyshim.git
